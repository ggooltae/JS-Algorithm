<!-- 한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출력하는 프로그램을 작성하세요. -->

<!-- (내풀이) t문자열의 index들을 구해놓고 이중포문으로 가장 짧은거리를 탐색해서 answer배열에 push함-->
<!-- 단점? 이중for문으로 인해 시간복잡도 O(n제곱)이다. -->
<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(s, t) {
        let answer = [];
        let indexes = [];
        let min;
        for (let i = 0; i < s.length; i++) {
          if (s[i] === t) indexes.push(i);
        }

        for (let i = 0; i < s.length; i++) {
          min = 100000;
          for (let j = 0; j < indexes.length; j++) {
            distance = Math.abs(i - indexes[j]);
            if (distance < min) min = distance;
          }
          answer.push(min);
        }
        return answer;
      }

      let str = "teachermode";
      console.log(solution(str, "e"));
    </script>
  </body>
</html>

<!-- for문을 앞에서뒤로 1번, 뒤에서앞으로 1번 돌면서 t문자열을 발견할 경우 answer에 0을넣고,
     t문자열과 일치하지않을경우 answer배열에 p++값을 넣음(뒤에서 앞으로 갈떄는 이미 answer배열에 값이 들어가있으므로, p와 이미있는값 중 작은값을 넣음)  -->
<!-- for문을 2번 도는것 뿐이기 때문에, 복잡도는  O(n)이다. -->
<!-- function solution(s, t){
    let answer=[];
    let p=1000;
    for(let x of s){ 
        if(x===t){
            p=0;
            answer.push(p);
        }
        else{
            p++;
            answer.push(p);
        }
    }
    p=1000;
    for(let i=s.length-1; i>=0; i--){
        if(s[i]===t) p=0;
        else{
            p++;
            answer[i]=Math.min(answer[i], p);
        }
    }
    return answer;
} -->
