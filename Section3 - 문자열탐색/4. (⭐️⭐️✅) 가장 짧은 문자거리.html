<!-- 한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출 력하는 프로그램을 작성하세요.

▣ 입력설명
첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다. 문자열의 길이는 100을 넘지 않는다.

▣ 출력설명
첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다. -->

<!-- for문을 앞에서뒤로 1번, 뒤에서앞으로 1번 돌면서 t문자열을 발견할 경우 answer에 0을넣고,
     t문자열과 일치하지않을경우 answer배열에 p++값을 넣음(뒤에서 앞으로 갈떄는 이미 answer배열에 값이 들어가있으므로, p와 이미있는값 중 작은값을 넣음)  -->
<!-- for문을 2번 도는것 뿐이기 때문에, 복잡도는  O(n)이다. -->

<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(s, t) {
        let answer = Array.from({ length: s.length }, () => 101);
        let point = 10000;
        for (let i = 0; i < s.length; i++) {
          if (s[i] === t) {
            point = 0;
            answer[i] = point;
          } else answer[i] = ++point;
        }
        point = 10000;
        for (let i = s.length - 1; i >= 0; i--) {
          if (s[i] === t) point = 0;
          else answer[i] = Math.min(answer[i], ++point);
        }
        return answer;
      }

      let str = "teachermode";
      console.log(solution(str, "e"));
    </script>
  </body>
</html>

<!-- (내풀이) t문자열의 index들을 구해놓고 이중포문으로 가장 짧은거리를 탐색해서 answer배열에 push함-->
<!-- 단점? 이중for문으로 인해 시간복잡도 O(n제곱)이다. -->
<!-- function solution(s, t) {
  let answer = [];
  let indexes = [];
  let min;
  for (let i = 0; i < s.length; i++) {
    if (s[i] === t) indexes.push(i);
  }

  for (let i = 0; i < s.length; i++) {
    min = 100000;
    for (let j = 0; j < indexes.length; j++) {
      distance = Math.abs(i - indexes[j]);
      if (distance < min) min = distance;
    }
    answer.push(min);
  }
  return answer;
} -->
